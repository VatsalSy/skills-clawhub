#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "httpx>=0.28.1",
#     "typer>=0.20.1",
#     "rich>=14.2.0",
# ]
# ///

from __future__ import annotations

import base64
import secrets
import threading
import urllib.parse
import webbrowser
from pathlib import Path
from http.server import BaseHTTPRequestHandler, HTTPServer

import httpx
import typer
from rich.console import Console

AUTHORIZE_URL = "https://dida365.com/oauth/authorize"
TOKEN_URL = "https://dida365.com/oauth/token"
DEFAULT_SCOPE = "tasks:read tasks:write"
CONFIG_DIR = Path.home() / ".config" / "ticktick-official"
TOKEN_ENV_FILE = CONFIG_DIR / "token.env"
APP_ENV_FILE = CONFIG_DIR / "app.env"
ENV_CLIENT_ID = "TICKTICK_CLIENT_ID"
ENV_CLIENT_SECRET = "TICKTICK_CLIENT_SECRET"
ENV_REDIRECT_URI = "TICKTICK_REDIRECT_URI"

app = typer.Typer(no_args_is_help=True, help="Dida365 官方 OAuth 辅助脚本（无第三方中转）。")
console = Console()


def build_auth_url(client_id: str, redirect_uri: str, scope: str, state: str) -> str:
    query = urllib.parse.urlencode(
        {
            "client_id": client_id,
            "scope": scope,
            "state": state,
            "redirect_uri": redirect_uri,
            "response_type": "code",
        }
    )
    return f"{AUTHORIZE_URL}?{query}"


def parse_env_file(path: Path) -> dict[str, str]:
    data: dict[str, str] = {}
    if not path.exists():
        return data
    for line in path.read_text(encoding="utf-8").splitlines():
        text = line.strip()
        if not text or text.startswith("#"):
            continue
        if text.startswith("export "):
            text = text[len("export "):].strip()
        if "=" not in text:
            continue
        key, value = text.split("=", 1)
        data[key.strip()] = value.strip().strip('"').strip("'")
    return data


def save_app_config(client_id: str, client_secret: str, redirect_uri: str, path: Path = APP_ENV_FILE) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    content = (
        "# Generated by ticktick_oauth.py\n"
        f'export {ENV_CLIENT_ID}="{client_id}"\n'
        f'export {ENV_CLIENT_SECRET}="{client_secret}"\n'
        f'export {ENV_REDIRECT_URI}="{redirect_uri}"\n'
    )
    path.write_text(content, encoding="utf-8")


def save_token(access_token: str, path: Path = TOKEN_ENV_FILE) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    content = (
        "# Generated by ticktick_oauth.py\n"
        "# Source: official Dida365 OAuth\n"
        f'export TICKTICK_TOKEN="{access_token}"\n'
    )
    path.write_text(content, encoding="utf-8")


def resolve_required(value: str | None, key: str, config: dict[str, str]) -> str:
    final = value or config.get(key)
    if not final:
        raise RuntimeError(f"缺少 {key}，请先执行 setup 命令或传参。")
    return final


def exchange_code(
    client_id: str,
    client_secret: str,
    code: str,
    redirect_uri: str,
    scope: str,
    timeout: float,
) -> dict:
    basic = base64.b64encode(f"{client_id}:{client_secret}".encode("utf-8")).decode("ascii")
    headers = {
        "Authorization": f"Basic {basic}",
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
    }
    data = {
        "code": code,
        "grant_type": "authorization_code",
        "scope": scope,
        "redirect_uri": redirect_uri,
    }

    with httpx.Client(timeout=timeout) as client:
        resp = client.post(TOKEN_URL, headers=headers, data=data)

    if resp.status_code >= 400:
        raise RuntimeError(f"换 token 失败 ({resp.status_code}): {resp.text}")

    payload = resp.json()
    if not payload.get("access_token"):
        raise RuntimeError(f"响应中缺少 access_token: {payload}")
    return payload


@app.command("auth-url", help="生成官方授权 URL。")
def auth_url(
    client_id: str = typer.Option(..., "--client-id"),
    redirect_uri: str = typer.Option(..., "--redirect-uri"),
    scope: str = typer.Option(DEFAULT_SCOPE, "--scope"),
    state: str = typer.Option(None, "--state", help="可选。为空时自动生成随机 state。"),
) -> None:
    final_state = state or secrets.token_urlsafe(24)
    url = build_auth_url(client_id, redirect_uri, scope, final_state)
    console.print("[green]授权地址：[/green]")
    console.print(url)
    console.print("\n[cyan]请保存 state 用于校验回调：[/cyan]", final_state)


@app.command("setup", help="保存 client_id/client_secret/redirect_uri 到本地配置，减少手动输入。")
def setup(
    client_id: str = typer.Option(..., "--client-id"),
    client_secret: str = typer.Option(..., "--client-secret"),
    redirect_uri: str = typer.Option("http://127.0.0.1:8765/callback", "--redirect-uri"),
) -> None:
    save_app_config(client_id, client_secret, redirect_uri)
    console.print(f"[green]已保存配置：[/green] {APP_ENV_FILE}")
    console.print("后续可直接运行：./scripts/ticktick_oauth.py login")


@app.command("exchange", help="用授权 code 换 access_token。")
def exchange(
    client_id: str | None = typer.Option(None, "--client-id"),
    client_secret: str | None = typer.Option(None, "--client-secret"),
    code: str = typer.Option(..., "--code"),
    redirect_uri: str | None = typer.Option(None, "--redirect-uri"),
    scope: str = typer.Option(DEFAULT_SCOPE, "--scope"),
    timeout: float = typer.Option(30.0, "--timeout", min=1.0),
    save: bool = typer.Option(True, "--save/--no-save", help="保存 token 到本地配置文件。"),
) -> None:
    config = parse_env_file(APP_ENV_FILE)
    try:
        final_client_id = resolve_required(client_id, ENV_CLIENT_ID, config)
        final_client_secret = resolve_required(client_secret, ENV_CLIENT_SECRET, config)
        final_redirect_uri = resolve_required(redirect_uri, ENV_REDIRECT_URI, config)
        payload = exchange_code(final_client_id, final_client_secret, code, final_redirect_uri, scope, timeout)
    except RuntimeError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(code=1)

    access_token = payload["access_token"]
    console.print("[green]换 token 成功。[/green]")
    console.print_json(data=payload)
    if save:
        save_token(access_token)
        console.print(f"[green]已保存 token：[/green] {TOKEN_ENV_FILE}")
    console.print("\n[bold]可直接执行：[/bold]")
    console.print(f'export TICKTICK_TOKEN="{access_token}"')


@app.command("login", help="一键本地回调登录：打开浏览器授权、自动接收 code、自动换 token。")
def login(
    client_id: str | None = typer.Option(None, "--client-id"),
    client_secret: str | None = typer.Option(None, "--client-secret"),
    redirect_uri: str | None = typer.Option(
        None,
        "--redirect-uri",
        help="必须与开发者中心配置一致。",
    ),
    scope: str = typer.Option(DEFAULT_SCOPE, "--scope"),
    state: str = typer.Option(None, "--state"),
    timeout: float = typer.Option(120.0, "--timeout", min=5.0, help="等待回调超时秒数。"),
    no_open: bool = typer.Option(False, "--no-open", help="不自动打开浏览器，只打印链接。"),
    save: bool = typer.Option(True, "--save/--no-save", help="保存 token 到本地配置文件。"),
) -> None:
    config = parse_env_file(APP_ENV_FILE)
    try:
        final_client_id = resolve_required(client_id, ENV_CLIENT_ID, config)
        final_client_secret = resolve_required(client_secret, ENV_CLIENT_SECRET, config)
        final_redirect_uri = resolve_required(
            redirect_uri,
            ENV_REDIRECT_URI,
            config,
        )
    except RuntimeError as e:
        console.print(f"[red]{e}[/red]")
        console.print("[yellow]先运行：./scripts/ticktick_oauth.py setup --client-id ... --client-secret ...[/yellow]")
        raise typer.Exit(code=1)

    parsed = urllib.parse.urlparse(final_redirect_uri)
    if parsed.scheme != "http" or parsed.hostname not in ("127.0.0.1", "localhost"):
        console.print("[red]login 模式仅支持本地 http 回调（localhost/127.0.0.1）。[/red]")
        raise typer.Exit(code=1)

    port = parsed.port or 80
    path = parsed.path or "/"
    host = parsed.hostname or "127.0.0.1"
    final_state = state or secrets.token_urlsafe(24)
    auth_link = build_auth_url(final_client_id, final_redirect_uri, scope, final_state)

    result: dict[str, str | None] = {"code": None, "state": None, "error": None}
    done = threading.Event()

    class CallbackHandler(BaseHTTPRequestHandler):
        def do_GET(self):  # noqa: N802
            req = urllib.parse.urlparse(self.path)
            if req.path != path:
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b"Not Found")
                return

            qs = urllib.parse.parse_qs(req.query)
            result["code"] = (qs.get("code") or [None])[0]
            result["state"] = (qs.get("state") or [None])[0]
            result["error"] = (qs.get("error") or [None])[0]

            ok = result["code"] and result["state"] == final_state and not result["error"]
            self.send_response(200 if ok else 400)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.end_headers()
            if ok:
                self.wfile.write(b"<h3>OAuth success. You can close this page.</h3>")
            else:
                self.wfile.write(b"<h3>OAuth failed. Check terminal logs.</h3>")
            done.set()

        def log_message(self, *_):
            return

    try:
        server = HTTPServer((host, port), CallbackHandler)
    except OSError as e:
        console.print(f"[red]无法监听回调地址 {host}:{port}：{e}[/red]")
        raise typer.Exit(code=1)

    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()

    console.print(f"[green]已监听回调：[/green] {final_redirect_uri}")
    console.print("[green]授权地址：[/green]")
    console.print(auth_link)

    if not no_open:
        webbrowser.open(auth_link)

    if not done.wait(timeout):
        server.shutdown()
        console.print("[red]等待 OAuth 回调超时。[/red]")
        raise typer.Exit(code=1)

    server.shutdown()

    if result["error"]:
        console.print(f"[red]授权返回错误：{result['error']}[/red]")
        raise typer.Exit(code=1)
    if result["state"] != final_state:
        console.print("[red]state 校验失败，已中止。[/red]")
        raise typer.Exit(code=1)
    if not result["code"]:
        console.print("[red]回调缺少 code。[/red]")
        raise typer.Exit(code=1)

    try:
        payload = exchange_code(
            client_id=final_client_id,
            client_secret=final_client_secret,
            code=str(result["code"]),
            redirect_uri=final_redirect_uri,
            scope=scope,
            timeout=min(timeout, 60.0),
        )
    except RuntimeError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(code=1)

    access_token = payload["access_token"]
    console.print("[green]登录成功，已拿到 access_token。[/green]")
    console.print_json(data=payload)
    if save:
        save_token(access_token)
        console.print(f"[green]已保存 token：[/green] {TOKEN_ENV_FILE}")
    console.print("\n[bold]可直接执行：[/bold]")
    console.print(f'export TICKTICK_TOKEN="{access_token}"')


if __name__ == "__main__":
    app()
